# design-pattern


# Builder 패턴

Builder 패턴은 객체를 생성하는 복잡한 과정을 추상화하고 단계별로 접근 가능하게 만드는 Creational Design Pattern(생성 패턴) 중 하나입니다. 이 패턴은 특히 객체의 생성 과정이 복잡하거나 여러 단계를 거쳐야 할 때 유용하게 사용됩니다. Builder 패턴을 사용하면 객체의 생성과정을 단순화하고 가독성을 높여 코드를 유지보수하기 쉽게 만들 수 있습니다.

## 주요 구성 요소

1. **Product (생성물)**: 생성할 객체의 클래스 또는 인터페이스를 정의합니다. 이 객체는 복잡한 구조를 가지고 있으며, 생성자에 많은 매개변수가 필요할 수 있습니다.

2. **Abstract Builder (추상 빌더)**: 객체를 생성하는데 필요한 메서드들을 정의한 인터페이스입니다. 일반적으로 객체의 각 부분을 생성하기 위한 메서드들을 포함하고 있습니다.

3. **Concrete Builder (구체적 빌더)**: Abstract Builder를 구현한 클래스로, 실제로 객체를 조립하는 역할을 합니다. 각각의 메서드는 Product의 부분들을 만들고 조립하는 역할을 합니다.

4. **Director (감독자)**: 객체의 생성 과정을 관리하고 조정하는 클래스입니다. 필요한 부분들을 Concrete Builder에게 전달하고, 최종적으로 Product를 반환 받습니다. Director는 클라이언트와 Builder 간의 인터페이스 역할을 합니다.

## 작동 방식

1. Client는 Director에게 객체를 생성하라는 요청을 합니다.

2. Director는 Concrete Builder에 필요한 부분들을 전달하고, 객체의 생성을 시작합니다.

3. Concrete Builder는 Product를 초기화하고, 각 부분들을 조립하여 최종적으로 완성된 Product를 반환합니다.

4. Client는 생성된 Product를 받아서 사용합니다.

## 활용 예시

Builder 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 복잡한 객체의 생성 과정이 필요한 경우 (예: 주문, 자동차 구성 등)
- 여러 다른 속성들의 조합으로 다양한 표현의 객체를 생성해야 하는 경우
- 객체 생성과정이 단계적이거나 선택적으로 진행되어야 하는 경우

## 장점

- 객체 생성 과정을 분리하여 복잡성을 감소시킵니다.
- 여러 개의 다른 표현(Representation)을 가진 객체를 생성할 수 있습니다.
- 객체 생성 과정에 대한 세부 사항을 클라이언트로부터 감춥니다.
- 객체를 단계별로 생성할 수 있으며, 필요한 부분만 빌드할 수 있습니다.

## 단점

- Concrete Builder의 구현에 따라서는 객체를 잘못 조립할 수 있는 위험이 있습니다.
- 객체의 부분들이 변하지 않는 한, 새로운 Concrete Builder를 추가하는 것은 비효율적일 수 있습니다.


---
# Chain of Responsibility 패턴

Chain of Responsibility 패턴은 행동 패턴 중 하나로, 요청을 처리하는 객체들의 연결(체인)을 만들어 역할을 분산시키는 패턴입니다. 요청을 처리할 수 있는 객체가 여러 개일 때, 이들 객체를 연결하여 하나의 체인을 형성하고, 요청이 체인을 따라서 순서대로 전달되면서 적절한 처리자가 요청을 처리하도록 합니다. 이를 통해 요청 발송자와 처리자를 분리하여 결합도를 낮추고, 유연성과 확장성을 향상시킬 수 있습니다.

## 주요 구성 요소

1. **Handler (처리자)**: 요청을 처리하는 인터페이스를 정의합니다. 처리 가능한 요청에 대한 메서드를 선언하고, 다음 처리자를 설정하거나 반환하는 메서드를 가질 수 있습니다.

2. **ConcreteHandler (구체적 처리자)**: Handler를 구현한 클래스로, 실제 요청 처리를 담당합니다. 자신이 처리할 수 없는 요청이라면 다음 처리자에게 요청을 전달합니다.

3. **Client (클라이언트)**: 요청을 발송하는 객체입니다. 이는 요청을 처리하는 체인의 시작점이며, 체인을 타고 요청이 전달됩니다.

## 작동 방식

1. Client가 요청을 생성하고 첫 번째 처리자인 ConcreteHandler에게 요청을 전달합니다.

2. ConcreteHandler는 해당 요청을 처리할 수 있는지 여부를 확인합니다. 만약 처리 가능하다면 요청을 처리하고 그렇지 않다면 다음 처리자인 다음 ConcreteHandler에게 요청을 전달합니다.

3. 이 과정이 반복되어 체인에 연결된 모든 ConcreteHandler들이 순서대로 요청을 처리합니다.

## 활용 예시

Chain of Responsibility 패턴은 다양한 상황에서 활용될 수 있습니다:

- 로깅 시스템에서 로그 레벨에 따라 처리기능을 나누는 경우.
- 사용자 인증 요청을 처리하는 시스템에서 인증 유형에 따라 다른 인증 핸들러를 사용하는 경우.
- 이메일 필터링 시스템에서 이메일을 필터링하는 과정을 처리하는 경우.

## 장점

- 요청 처리의 유연성과 확장성을 제공하며, 새로운 ConcreteHandler를 추가하거나 기존 처리자들의 순서를 변경할 수 있습니다.
- 요청 발송자와 처리자를 분리하여 코드의 결합도를 낮출 수 있습니다.
- 단일 책임 원칙(Single Responsibility Principle)을 따르고, 코드의 유지보수와 확장을 용이하게 만듭니다.

## 단점

- 모든 요청에 대해 처리자가 존재하지 않는다면 요청이 끝까지 처리되지 못할 수 있습니다.
- 너무 많은 ConcreteHandler가 존재하거나 체인의 길이가 매우 길어질 경우, 처리 속도가 느려질 수 있습니다.


---
# Composite 패턴

Composite 패턴은 객체들을 트리 구조로 구성하여, 개별 객체와 복합 객체(Composite)를 동일하게 다룰 수 있게 하는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 객체들 간의 계층 구조를 간단한 방법으로 구성할 수 있어서, 객체들의 구성과 그 구성들로 이루어진 복합 객체를 동일한 방식으로 다룰 수 있습니다.

## 주요 구성 요소

1. **Component (구성 요소)**: 복합 객체와 개별 객체에 공통 인터페이스를 정의합니다. 즉, Leaf(개별 객체)와 Composite(복합 객체)는 모두 Component를 구현합니다. 구성 요소는 복합 객체의 자식들을 추가하거나 삭제하는 메서드를 선언할 수 있습니다.

2. **Leaf (개별 객체)**: Component를 구현하는 클래스로, 복합 객체의 단말 노드에 해당합니다. Leaf는 더 이상 자식 요소를 가질 수 없습니다.

3. **Composite (복합 객체)**: Component를 구현하는 클래스로, 복합 객체를 나타냅니다. Composite는 Leaf와 다른 복합 객체들을 자식으로 가질 수 있습니다.

## 작동 방식

1. Component 인터페이스를 정의하고, Leaf와 Composite 클래스가 해당 인터페이스를 구현합니다.

2. Composite 객체는 Leaf 객체와 다른 Composite 객체를 자식으로 가질 수 있으며, 자식 요소들에 대한 추가/제거를 수행하는 메서드를 구현합니다.

3. Client는 Component 인터페이스를 통해 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있습니다. 따라서 복합 객체를 구성하는 개별 객체들과 복합 객체들을 모두 처리할 수 있습니다.

## 활용 예시

Composite 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 계층적인 구조를 가진 객체를 처리하는 경우 (예: 파일 시스템의 폴더와 파일)
- GUI 요소들을 트리 구조로 구성하여 일관성 있게 다루는 경우
- 조직 구조를 표현하는 시스템에서 부서와 직원들을 계층적으로 처리하는 경우

## 장점

- 객체들 간의 계층 구조를 쉽게 구성할 수 있습니다.
- 개별 객체와 복합 객체를 동일하게 취급하여 일관성 있게 처리할 수 있습니다.
- 새로운 Composite나 Leaf를 추가하여 계층 구조를 확장하는 것이 용이합니다.

## 단점

- Component 인터페이스에 공통 동작을 정의하는 것이 어려울 수 있습니다.
- 자식 요소들의 순회나 검색에 있어서 성능상의 문제가 발생할 수 있습니다.


---
# Decorator 패턴

Decorator 패턴은 객체의 기능을 동적으로 확장할 수 있는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 기본 객체를 감싸는 데코레이터(Decorator) 클래스를 사용하여 새로운 기능을 추가하거나 수정하는 방식으로 객체의 동작을 확장합니다. 이를 통해 기본 객체의 변경 없이 여러 기능들을 조합하거나 더하고, 유연하게 동작을 확장할 수 있습니다.

## 주요 구성 요소

1. **Component (구성 요소)**: 기본 기능을 정의하는 인터페이스 또는 추상 클래스입니다. ConcreteComponent와 Decorator 클래스는 모두 Component를 구현합니다.

2. **ConcreteComponent (구체적 구성 요소)**: Component를 구현하는 클래스로, 기본 기능을 제공합니다.

3. **Decorator (데코레이터)**: Component와 동일한 인터페이스를 구현하며, ConcreteComponent를 감싸는 데코레이터 역할을 합니다. 추가적인 기능을 제공하거나 수정합니다.

4. **ConcreteDecorator (구체적 데코레이터)**: Decorator를 상속받은 클래스로, 실제로 객체의 동작을 확장하는 역할을 합니다.

## 작동 방식

1. Component 인터페이스를 정의하고, 기본 동작을 구현한 ConcreteComponent 클래스를 작성합니다.

2. Decorator는 Component를 구현하며, 자신이 감싸고 있는 Component 객체를 인스턴스 변수로 가집니다. 데코레이터는 자신의 메서드 내에서 Component의 동작을 호출하고, 추가적인 기능을 수행합니다.

3. ConcreteDecorator는 Decorator를 상속받아 실제로 동작을 확장합니다. ConcreteDecorator는 필요한 기능을 추가하고, 부모 클래스의 메서드를 호출하여 객체의 동작을 확장합니다.

4. Client는 ConcreteComponent 객체를 생성하고, 필요한 Decorator 객체들을 추가하여 원하는 기능을 동적으로 조합할 수 있습니다.

## 활용 예시

Decorator 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 기본 기능에 여러 추가 기능들을 조합하여 다양한 변화를 만들어야 할 때 (예: 커피 주문에 여러 가지 토핑을 선택하는 경우)
- 상속을 통한 확장보다는 런타임 시점에서 객체의 동작을 확장하고 싶을 때
- 객체의 변경 없이도 기능을 동적으로 추가하고 수정할 수 있어야 할 때

## 장점

- 기본 객체를 수정하지 않고도 기능을 동적으로 확장할 수 있습니다.
- 객체의 구성을 통해 기능을 추가하므로 상속보다 유연하고 확장성이 더 높습니다.
- 기능들을 독립적으로 조합하여 원하는 변화를 만들 수 있습니다.

## 단점

- 많은 수의 데코레이터 클래스들이 생성될 수 있으며, 이로 인해 복잡성이 증가할 수 있습니다.
- 데코레이터 패턴을 오용하면 클래스들이 많이 중첩되어 코드를 이해하기 어려워질 수 있습니다.


---
# Facade 패턴

Facade 패턴은 복잡한 시스템 또는 서브시스템의 인터페이스에 대한 단순한 통합 인터페이스를 제공하는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 큰 규모의 시스템을 구성하는 다양한 클래스나 모듈들을 간단한 인터페이스로 래핑하여 클라이언트가 쉽게 사용할 수 있도록 해줍니다. 즉, 복잡한 시스템을 단순화하고 클라이언트의 사용성을 높이는데 중점을 둔 패턴입니다.

## 주요 구성 요소

1. **Facade (퍼사드)**: 복잡한 시스템 또는 서브시스템의 인터페이스에 대한 단순한 통합 인터페이스를 제공합니다. 클라이언트는 퍼사드를 통해 시스템의 다양한 기능을 사용할 수 있습니다.

2. **Subsystem (서브시스템)**: 퍼사드를 구성하는 여러 개의 클래스 또는 모듈들로, 특정 기능을 제공합니다. 서브시스템은 퍼사드에 의해 래핑되어 퍼사드를 통해서만 접근 가능합니다.

## 작동 방식

1. 퍼사드는 복잡한 시스템의 인터페이스를 단순화하여 클라이언트에게 제공합니다. 이 인터페이스는 시스템의 다양한 기능들을 호출하는 메서드들로 구성됩니다.

2. 클라이언트는 퍼사드를 통해서만 서브시스템의 기능들을 사용할 수 있습니다. 즉, 클라이언트는 서브시스템의 내부 구조를 알 필요 없이 단순히 퍼사드를 호출하여 기능을 실행할 수 있습니다.

3. 퍼사드는 클라이언트의 요청을 받아 내부적으로 필요한 서브시스템의 기능들을 호출하고, 클라이언트에게 결과를 반환합니다.

## 활용 예시

Facade 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 복잡한 라이브러리 또는 프레임워크를 사용할 때, 퍼사드를 통해 필요한 기능들만 노출시켜 사용성을 개선할 수 있습니다.
- 다양한 서브시스템들을 간단한 통합 인터페이스로 제공하여 복잡성을 감소시킬 수 있습니다.
- 기존 시스템을 리팩토링할 때, 퍼사드를 도입하여 외부 인터페이스를 보다 간결하게 만들 수 있습니다.

## 장점

- 복잡한 시스템의 사용성을 개선하고, 외부에 간단한 통합 인터페이스를 제공합니다.
- 시스템의 내부 구조를 감추어 모듈 간의 결합도를 낮추고 유연성을 향상시킵니다.
- 클라이언트와 서브시스템 사이의 의존성을 줄여 시스템의 확장성을 증가시킵니다.

## 단점

- 퍼사드에 새로운 기능을 추가하거나 기존 기능을 수정할 때, 모든 클라이언트들에게 영향을 미칠 수 있습니다.
- 퍼사드가 과도하게 많은 기능들을 노출할 경우, 퍼사드의 역할이 모호해질 수 있습니다.


---
# Factory Method 패턴

Factory Method 패턴은 객체를 생성하는 인터페이스를 정의하고, 객체의 인스턴스화를 서브클래스로 미루는 Creational Design Pattern(생성 패턴) 중 하나입니다. 이 패턴은 객체 생성 과정을 캡슐화하여 클라이언트 코드에서 구상 클래스(Concrete Class)와의 결합도를 낮춥니다. 이를 통해 유연성을 향상시키고, 새로운 객체를 생성하거나 기존의 객체 생성 방식을 변경하기 쉽게 만듭니다.

## 주요 구성 요소

1. **Creator (창조자)**: 객체를 생성하는 팩토리 메서드를 선언하는 클래스입니다. 일반적으로 Creator는 추상 클래스로 정의됩니다. Creator 클래스는 제품(Product)의 인스턴스를 반환하는 추상 팩토리 메서드를 선언합니다.

2. **ConcreteCreator (구체적 창조자)**: Creator를 상속받은 클래스로, 구체적인 팩토리 메서드를 구현합니다. 이 클래스에서는 실제로 제품의 인스턴스를 생성하여 반환합니다.

3. **Product (제품)**: 팩토리 메서드에 의해 생성되는 객체의 인터페이스를 정의합니다. ConcreteProduct 클래스들은 모두 Product를 구현합니다.

4. **ConcreteProduct (구체적 제품)**: Product를 구현하는 클래스로, 실제 객체의 인스턴스를 나타냅니다.

## 작동 방식

1. Creator 추상 클래스는 제품의 생성을 담당하는 팩토리 메서드를 선언합니다. 이 메서드는 Product 인터페이스를 반환하며, 구체적인 제품의 인스턴스를 생성합니다.

2. ConcreteCreator 클래스들은 Creator를 상속받아 구체적인 팩토리 메서드를 구현합니다. 이 구현에서는 실제로 Product의 인스턴스를 생성하고 반환합니다.

3. 클라이언트는 Creator 객체를 사용하여 제품을 생성합니다. 클라이언트는 구체적인 제품 클래스를 직접 알 필요가 없으며, Creator의 팩토리 메서드를 호출함으로써 새로운 제품을 얻을 수 있습니다.

## 활용 예시

Factory Method 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 객체 생성 코드를 클라이언트 코드로부터 분리하여 결합도를 낮추고 유연성을 향상시킬 때
- 서로 다른 제품들이 동일한 인터페이스를 가져야 하며, 이들을 생성하는 방식이 다를 때
- 객체 생성과 관련된 복잡한 로직이 존재할 때, 이를 팩토리 메서드로 캡슐화하여 관리하기 쉽게 만들 때

## 장점

- 객체 생성 코드와 사용 코드를 분리하여 클라이언트 코드의 복잡성을 낮춥니다.
- 객체 생성 방식을 변경하거나 새로운 제품을 추가하는 것이 용이합니다.
- 확장성과 유연성을 높여 객체 생성에 대한 결정을 나중에 내리거나, 런타임에 결정할 수 있습니다.

## 단점

- 제품마다 별도의 ConcreteCreator 클래스가 필요합니다. 제품이 많아질 경우 클래스의 개수가 증가하여 유지보수에 어려움을 초래할 수 있습니다.
- 팩토리 메서드에 대한 오버헤드가 있을 수 있습니다. 단순한 객체 생성에 비해 불필요하게 복잡해질 수 있습니다.


---
# Flyweight 패턴

Flyweight 패턴은 객체들 간에 공유 가능한 데이터를 효율적으로 관리하여 메모리 사용량을 줄이는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 많은 수의 유사한 객체들이 존재하지만 상태가 유사하거나 동일한 경우, 중복된 데이터를 공유함으로써 메모리 사용을 최소화합니다. 이를 통해 대량의 객체를 효율적으로 생성하고 관리할 수 있습니다.

## 주요 구성 요소

1. **Flyweight (플라이웨이트)**: 공유 가능한 객체를 나타내는 인터페이스 또는 추상 클래스입니다. Flyweight 인터페이스는 공유 상태를 관리하는 메서드를 선언합니다.

2. **ConcreteFlyweight (구체적 플라이웨이트)**: Flyweight 인터페이스를 구현한 클래스로, 실제로 공유 가능한 객체를 나타냅니다. 공유 가능한 상태를 가질 수 있습니다.

3. **FlyweightFactory (플라이웨이트 팩토리)**: Flyweight 객체들을 생성하고 관리하는 팩토리 클래스입니다. FlyweightFactory는 이미 생성된 Flyweight 객체들을 캐싱하여 중복 생성을 방지합니다.

4. **Client (클라이언트)**: Flyweight 객체들을 사용하는 클라이언트 코드입니다. Client는 FlyweightFactory를 통해 Flyweight 객체들을 요청합니다.

## 작동 방식

1. Flyweight 패턴에서는 중복되는 데이터를 공유 가능한 상태로 정의합니다. 이러한 공유 가능한 상태를 Flyweight 객체라고 합니다.

2. FlyweightFactory 클래스는 Flyweight 객체들을 생성하고 관리합니다. 이미 생성된 Flyweight 객체들은 캐싱하여 중복 생성을 방지합니다.

3. 클라이언트 코드에서는 FlyweightFactory를 통해 Flyweight 객체를 요청하고, 공유 가능한 상태를 설정합니다.

4. 클라이언트 코드에서 Flyweight 객체를 사용하면서 필요한 상태를 설정하여 동작합니다. Flyweight 객체는 공유되는 상태와 클라이언트별로 다르게 유지되는 상태를 가집니다.

## 활용 예시

Flyweight 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 대량의 객체들이 존재하고 이들이 유사한 상태를 가지는 경우 (예: 문자열, 이미지 객체 등)
- 객체들의 생성 비용이 높고, 많은 수의 객체들을 효율적으로 관리해야 하는 경우
- 상태를 공유하는 객체들을 캐싱하여 성능을 개선해야 하는 경우

## 장점

- 메모리 사용을 줄여 대량의 객체를 효율적으로 생성하고 관리할 수 있습니다.
- 공유 상태를 갖는 객체들을 중복 생성하는 것을 방지하여 자원을 절약합니다.
- 유사한 객체들을 관리하기 쉽고, 성능 향상을 이룰 수 있습니다.

## 단점

- 공유 상태와 고유 상태의 구분이 필요하며, 객체의 설계와 관리가 복잡해질 수 있습니다.
- 객체들의 상태가 변경되는 경우 주의가 필요하며, 모든 클라이언트들에게 영향을 미칠 수 있습니다.


---
# Proxy 패턴

Proxy 패턴은 다른 객체에 대한 대리자(Proxy)를 제공하여, 객체에 대한 접근을 제어하고 추가적인 기능을 제공하는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 객체의 접근을 간접적으로 관리함으로써 객체에 대한 추가적인 작업을 수행하거나, 객체에 대한 접근을 제한하고 보안을 강화하는데 사용됩니다.

## 주요 구성 요소

1. **Subject (주체)**: 실제 객체와 대리자 객체가 공유하는 인터페이스를 정의합니다. 주체는 클라이언트와 대리자 사이의 공통 인터페이스를 나타냅니다.

2. **RealSubject (실제 주체)**: 주체의 실제 구현을 나타냅니다. 실제 주체는 주로 시간이 오래 걸리거나 공간을 많이 차지하는 작업 등을 수행하는 클래스입니다.

3. **Proxy (대리자)**: 실제 주체에 대한 참조를 유지하고, 실제 주체의 작업을 수행하기 전 또는 후에 추가적인 기능을 제공합니다. Proxy 클래스는 주체와 동일한 인터페이스를 구현하여 클라이언트에게 주체와 동일하게 보이도록 합니다.

## 작동 방식

1. 클라이언트는 Proxy 객체를 사용하여 실제 주체에 접근합니다. Proxy 객체는 실제 주체에 대한 참조를 가지고 있습니다.

2. Proxy 객체는 클라이언트의 요청을 받아 실제 주체에 전달합니다. 이때, Proxy는 추가적인 작업을 수행하거나 실제 주체에 접근을 제한할 수 있습니다.

3. 실제 주체는 Proxy 객체로부터 받은 요청을 처리하고, 결과를 다시 Proxy를 통해 클라이언트에게 반환합니다.

## 활용 예시

Proxy 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 실제 객체의 생성 비용이 높거나, 많은 시간이 소요되는 작업이 포함된 경우
- 객체에 대한 접근을 제어하고, 보안을 강화하려는 경우
- 객체에 대한 추가적인 기능을 제공하고 싶은 경우 (예: 로깅, 캐싱, 인증 등)

## 장점

- 실제 객체의 생성과 초기화를 늦추어 불필요한 자원 소비를 방지합니다.
- 객체에 대한 접근을 간접적으로 관리함으로써 보안을 강화하거나, 객체에 추가적인 기능을 제공할 수 있습니다.
- 클라이언트 코드가 실제 객체와 Proxy 객체를 동일하게 다룰 수 있어 유연성을 높입니다.

## 단점

- Proxy 객체를 추가함으로써 코드의 복잡성이 증가할 수 있습니다.
- Proxy 객체를 잘못 설계하면 성능 저하나 오버헤드가 발생할 수 있습니다.


---
# Singleton 패턴

Singleton 패턴은 단 하나의 인스턴스만 생성하고, 어디서든지 접근 가능한 객체를 생성하는 Creational Design Pattern(생성 패턴) 중 하나입니다. 이 패턴은 하나의 클래스가 오직 하나의 인스턴스만을 가지도록 보장하여, 중복된 인스턴스 생성을 방지하고 전역적으로 접근 가능한 접근 지점을 제공합니다.

## 주요 특징

- 생성자를 private으로 선언하여 외부에서 인스턴스를 생성하는 것을 방지합니다.
- 정적 메서드를 사용하여 유일한 인스턴스에 접근할 수 있는 공통된 접근 지점을 제공합니다.
- 멀티스레드 환경에서도 안전하게 인스턴스를 생성하고 접근할 수 있도록 구현해야 합니다.

## 작동 방식

1. Singleton 패턴은 생성자를 private으로 선언하여 외부에서의 객체 생성을 막습니다. 따라서 클래스 내부에서만 객체를 생성할 수 있습니다.

2. 정적 메서드를 사용하여 유일한 인스턴스에 접근할 수 있는 접근 지점을 제공합니다. 이 메서드는 항상 동일한 인스턴스를 반환합니다.

3. 최초로 정적 메서드를 호출할 때 인스턴스가 생성되며, 그 이후로는 이미 생성된 인스턴스를 반환합니다. 이렇게 하면 여러 곳에서 동일한 인스턴스를 사용할 수 있습니다.

## 활용 예시

Singleton 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 설정 정보, 로그 객체 등과 같이 어플리케이션 전반에 걸쳐 하나의 인스턴스만 필요한 경우
- 데이터베이스 연결, 네트워크 연결 등과 같이 리소스가 많이 소모되는 객체를 여러 번 생성하지 않도록 할 때
- 상태를 가지고 있는 객체를 여러 곳에서 공유하고 동기화할 필요가 있는 경우

## 장점

- 하나의 인스턴스만 생성되기 때문에 자원의 낭비를 방지하고, 전역적으로 접근 가능한 공유 지점을 제공합니다.
- 인스턴스 생성과 초기화를 늦출 수 있어 애플리케이션 시작 시간을 최적화할 수 있습니다.
- 다양한 클래스 간의 상태를 공유하여 효율적인 데이터 공유가 가능합니다.

## 단점

- 싱글톤 인스턴스가 전역적으로 접근 가능하므로, 다른 클래스와 강한 결합을 가질 수 있습니다.
- 멀티스레드 환경에서 인스턴스의 생성과 동시 접근에 대한 동기화 처리가 필요할 수 있습니다.
- 테스트를 어렵게 만들 수 있으며, 싱글톤 객체에 대한 의존성으로 인해 테스트가 복잡해질 수 있습니다.
