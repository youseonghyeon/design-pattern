# Chain of Responsibility 패턴

Chain of Responsibility 패턴은 행동 패턴 중 하나로, 요청을 처리하는 객체들의 연결(체인)을 만들어 역할을 분산시키는 패턴입니다. 요청을 처리할 수 있는 객체가 여러 개일 때, 이들 객체를 연결하여 하나의 체인을 형성하고, 요청이 체인을 따라서 순서대로 전달되면서 적절한 처리자가 요청을 처리하도록 합니다. 이를 통해 요청 발송자와 처리자를 분리하여 결합도를 낮추고, 유연성과 확장성을 향상시킬 수 있습니다.

## 주요 구성 요소

1. **Handler (처리자)**: 요청을 처리하는 인터페이스를 정의합니다. 처리 가능한 요청에 대한 메서드를 선언하고, 다음 처리자를 설정하거나 반환하는 메서드를 가질 수 있습니다.

2. **ConcreteHandler (구체적 처리자)**: Handler를 구현한 클래스로, 실제 요청 처리를 담당합니다. 자신이 처리할 수 없는 요청이라면 다음 처리자에게 요청을 전달합니다.

3. **Client (클라이언트)**: 요청을 발송하는 객체입니다. 이는 요청을 처리하는 체인의 시작점이며, 체인을 타고 요청이 전달됩니다.

## 작동 방식

1. Client가 요청을 생성하고 첫 번째 처리자인 ConcreteHandler에게 요청을 전달합니다.

2. ConcreteHandler는 해당 요청을 처리할 수 있는지 여부를 확인합니다. 만약 처리 가능하다면 요청을 처리하고 그렇지 않다면 다음 처리자인 다음 ConcreteHandler에게 요청을 전달합니다.

3. 이 과정이 반복되어 체인에 연결된 모든 ConcreteHandler들이 순서대로 요청을 처리합니다.

## 활용 예시

Chain of Responsibility 패턴은 다양한 상황에서 활용될 수 있습니다:

- 로깅 시스템에서 로그 레벨에 따라 처리기능을 나누는 경우.
- 사용자 인증 요청을 처리하는 시스템에서 인증 유형에 따라 다른 인증 핸들러를 사용하는 경우.
- 이메일 필터링 시스템에서 이메일을 필터링하는 과정을 처리하는 경우.

## 장점

- 요청 처리의 유연성과 확장성을 제공하며, 새로운 ConcreteHandler를 추가하거나 기존 처리자들의 순서를 변경할 수 있습니다.
- 요청 발송자와 처리자를 분리하여 코드의 결합도를 낮출 수 있습니다.
- 단일 책임 원칙(Single Responsibility Principle)을 따르고, 코드의 유지보수와 확장을 용이하게 만듭니다.

## 단점

- 모든 요청에 대해 처리자가 존재하지 않는다면 요청이 끝까지 처리되지 못할 수 있습니다.
- 너무 많은 ConcreteHandler가 존재하거나 체인의 길이가 매우 길어질 경우, 처리 속도가 느려질 수 있습니다.
