# Decorator 패턴

Decorator 패턴은 객체의 기능을 동적으로 확장할 수 있는 Structural Design Pattern(구조 패턴) 중 하나입니다. 이 패턴은 기본 객체를 감싸는 데코레이터(Decorator) 클래스를 사용하여 새로운 기능을 추가하거나 수정하는 방식으로 객체의 동작을 확장합니다. 이를 통해 기본 객체의 변경 없이 여러 기능들을 조합하거나 더하고, 유연하게 동작을 확장할 수 있습니다.

## 주요 구성 요소

1. **Component (구성 요소)**: 기본 기능을 정의하는 인터페이스 또는 추상 클래스입니다. ConcreteComponent와 Decorator 클래스는 모두 Component를 구현합니다.

2. **ConcreteComponent (구체적 구성 요소)**: Component를 구현하는 클래스로, 기본 기능을 제공합니다.

3. **Decorator (데코레이터)**: Component와 동일한 인터페이스를 구현하며, ConcreteComponent를 감싸는 데코레이터 역할을 합니다. 추가적인 기능을 제공하거나 수정합니다.

4. **ConcreteDecorator (구체적 데코레이터)**: Decorator를 상속받은 클래스로, 실제로 객체의 동작을 확장하는 역할을 합니다.

## 작동 방식

1. Component 인터페이스를 정의하고, 기본 동작을 구현한 ConcreteComponent 클래스를 작성합니다.

2. Decorator는 Component를 구현하며, 자신이 감싸고 있는 Component 객체를 인스턴스 변수로 가집니다. 데코레이터는 자신의 메서드 내에서 Component의 동작을 호출하고, 추가적인 기능을 수행합니다.

3. ConcreteDecorator는 Decorator를 상속받아 실제로 동작을 확장합니다. ConcreteDecorator는 필요한 기능을 추가하고, 부모 클래스의 메서드를 호출하여 객체의 동작을 확장합니다.

4. Client는 ConcreteComponent 객체를 생성하고, 필요한 Decorator 객체들을 추가하여 원하는 기능을 동적으로 조합할 수 있습니다.

## 활용 예시

Decorator 패턴은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

- 기본 기능에 여러 추가 기능들을 조합하여 다양한 변화를 만들어야 할 때 (예: 커피 주문에 여러 가지 토핑을 선택하는 경우)
- 상속을 통한 확장보다는 런타임 시점에서 객체의 동작을 확장하고 싶을 때
- 객체의 변경 없이도 기능을 동적으로 추가하고 수정할 수 있어야 할 때

## 장점

- 기본 객체를 수정하지 않고도 기능을 동적으로 확장할 수 있습니다.
- 객체의 구성을 통해 기능을 추가하므로 상속보다 유연하고 확장성이 더 높습니다.
- 기능들을 독립적으로 조합하여 원하는 변화를 만들 수 있습니다.

## 단점

- 많은 수의 데코레이터 클래스들이 생성될 수 있으며, 이로 인해 복잡성이 증가할 수 있습니다.
- 데코레이터 패턴을 오용하면 클래스들이 많이 중첩되어 코드를 이해하기 어려워질 수 있습니다.
